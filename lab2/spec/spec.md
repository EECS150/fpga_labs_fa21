# FPGA Lab 2: Introduction to FPGA Development
<p align="center">
Prof. Bora Nikolic
</p>
<p align="center">
TAs: Alisha Menon, Zhenghan Lin, Charles Hong, Vighnesh Iyer
</p>
<p align="center">
Department of Electrical Engineering and Computer Science
</p>
<p align="center">
College of Engineering, University of California, Berkeley
</p>

### Before You Start This Lab
Make sure that you have gone through and completed the steps involved in Lab 1.
Let the TA know if you are not signed up for this class on Piazza or if you do not have a class account (eecs151-xxx), so we can get that sorted out.

To fetch the skeleton files for this lab, `cd` to the git repository (`fpga_labs_fa21`) that you had cloned in the first lab and execute the command `git pull`.

Go through the [Verilog Primer Slides](http://inst.eecs.berkeley.edu/~eecs151/fa21/files/verilog/Verilog_Primer_Slides.pdf); you should feel somewhat comfortable with the basics of Verilog to complete this lab.

## A Structural and Behavioral Adder Design

### Build a Structural 14-bit Adder
To help you with this task, please refer to the `Code Generation with for-generate loops' slide in the Verilog Primer Slides (slide 35).

- Open `lab2/src/full_adder.v`; fill in the logic to produce the full adder outputs from the inputs
- Open `structural_adder.v` and construct a ripple carry adder using the full adder cells you designed earlier and a 'for-generate loop'.
- Finally, inspect the `z1top_adder.v` top-level module and see how your structural adder is instantiated and hooked up to the top-level signals. For now, just look at the `user_adder` instance of your structural adder. As we learned in previous lab, the basic I/O options on the Z1 board are limited. How are we managing to input two 3-bit integers?
- Run bitstream generation as usual. Like last time, we have provided a Makefile that automates calling Vivado. This allows you to run synthesis with `make synth` and place and route/generate bitstream with `make impl`.
- Program the FPGA with `make program` and test out the design. Try entering different binary numbers into your adder with the switches and buttons and see that the correct sum is displayed on the IO LEDs.

### Build a Behavioral 14-bit Adder
Check out `behavioral_adder.v`. It has already been filled with the appropriate logic for you. Notice how behavioral Verilog allows you to describe the function of a circuit rather than the topology or implementation.

In `z1top_adder.v`, you can see that the `structural_adder` and the `behavioral_adder` are both instantiated in the self-test section. A module called `adder_tester` has been written for you that will check that the sums generated by both your adders are equal for all possible input combinations. If both your adders are operating identically, both RGB LEDs will light up. Verify this on your board.


## Simulating the Adder
Let's run some simulations on the adder in software to check it works. Typically, this is done before putting our design on the FPGA, but because the adder is simple, we started with the FPGA this time.
To do this, we will need to use a Verilog testbench.
A Verilog testbench is designed to test a Verilog module by supplying it with the inputs it needs (stimulus signals) and testing whether the outputs of the module match what we expect.

### Overview of Testbench Skeleton
Check the provided testbench skeleton in `sim/adder_testbench.v`.
Let's go through what every line of this testbench does.

```verilog
`timescale 1ns/1ns
```

The timescale declaration needs to be at the top of every testbench file.
```verilog
`timescale (simulation step time)/(simulation resolution)
```

The first argument to the timescale declaration is the simulation step time.
It defines the granularity of discrete time units in which the simulation advances.
In this case, we have defined the simulation step time to be one nanosecond, so we can advance the simulation time by as little as 1ns at a time.

The second argument to the timescale declaration is the simulation resolution.
In our example it is also 1ns.
The resolution allows the simulator to model transient behavior of your circuit in between simulation time steps.
For this lab, we aren't modeling any gate delays, so the resolution can safely equal the step time.

```verilog
`define SECOND 1000000000
`define MS 1000000
```

These are some macros defined for our testbench.
They are constant values you can use when writing your testbench to simplify your code and make it obvious what certain numbers mean.
For example, `SECOND` is defined as the number of nanoseconds in one second.

```verilog
module adder_testbench();
  // Testbench code goes here
endmodule
```

`adder_testbench` is a testbench module.
It is not intended to be placed on an FPGA, but rather it is to be run by a circuit simulator.
All your testbench code goes in this module.
We will instantiate our DUT (device under test) in this module.

```verilog
reg [13:0] a = 0;
reg [13:0] b;
wire [14:0] sum;
```

Here are the inputs and outputs of our adder.
Notice that the inputs to the `counter` are declared as `reg` type nets and the outputs are declared as `wire` type nets.
This is because we will be driving the inputs in our testbench inside an `initial` block and we will be reading the output.
Note we can set the initial value of `reg` nets in the testbench to drive a particular value into the DUT at time 0 (e.g. `a`).

```verilog
structural_adder sa (
  .a(a),
  .b(b),
  .sum(sum)
);
```

Now we instantiate the DUT and connect its ports to the nets we have declared in our testbench.

```verilog
initial begin
  a = 14'd1;
  b = 14'd1;
  #(10 * `MS);
  ...
  $finish();
end
```

This is the body of our testbench.
The `initial begin ... end` block is the 'main()' function for our testbench, and where the simulation begins execution.
In the `initial` block we drive the DUT inputs using blocking (`=`) assignments.
We can also order the simulator to advance simulation time using delay statements.
A delay statement takes the form `#(delay in time steps);`.
For instance the statement `#(100);` would run the simulation for 100ns.
In this case, we set `BUTTONS` to 0 at the start of the simulation, let the simulation run for 10ms, then set \verb|output_enable| to 1.
Then `a` and `b` are changed several times, and the adder provides new sums.
The final statement is a system function: the `$finish()` function tells the simulator to halt the simulation.

### Running the Simulation
There are 2 RTL simulators we can use:
- **VCS** - proprietary, only available on lab machines, fast
<!-- - **XSIM** - free, bundled with Vivado, somewhat slower -->
- **Icarus Verilog** - open source, runs on Windows/OSX/Linux, somewhat slower

They all take in Verilog RTL and a Verilog testbench module and output:
- A waveform file (.vpd, .vcd, .fst) that plots each signal in the testbench and DUT across time
- A text dump containing anything that was printed during the testbench execution

#### VCS
If you're using the lab machines, you should use VCS:
```shell
make sim/tone_generator_testbench.vpd
```
This will generate a waveform file `sim/adder_testbench.vpd` which you can view using `dve`.
Login to the lab machines physically or use X2go and run:
```shell
dve -vpd sim/tone_generator_testbench.vpd &
```

<p align="center">
<img src="./figs/dve.png" width="800" />
</p>

From left to right, you can see the `Hierarchy', `Signals', and `Source Code' windows.
The `Hierarchy' window lets you select a particular module instance in the testbench to view its signals.
In the `Signals' window, you can select multiple signals (by Shift-clicking) and then right-click → 'Add To Waves' → 'New Wave View' to plot the waveforms for the selected signals.

<p align="center">
<img src="./figs/dve_wave.png" width="800" />
</p>

Here are a few useful shortcuts:
- **Click on waveform**: Sets cursor position
- **O**: Zoom out of waveform
- **+**: Zoom into waveform
- **F**: Fit entire waveform into viewer (zoom full)
- **Left Click + Drag Left/Right**: Zoom in on waveform section

<!-- #### XSIM
Vivado has an integrated simulator, `xsim`, that can run your Verilog testbench.
You can run XSIM on your laptop.
 -->
 
#### Icarus Verilog
Icarus Verilog is available on the lab machines.
To install Icarus and gtkwave locally, refer to the appendix.

Run `make sim/tone_generator_testbench.fst` to launch a simulation with Icarus and to produce a FST waveform file.
You can open the FST with gtkwave locally or on the lab machines.

### Analyzing the Simulation
After opening the waveform, you should be able to see the signals change as specified in the testbench.
For example, you should see the `a` signal start at 1 and then become 0 after 10 ms.

### Helpful Tip: Reloading Waveforms
When you re-run your simulation and you want to plot the newly generated signals in DVE or gtkwave, you don't need to close and reopen the waveform viewer.
Use Shift + Ctrl + R in gtkwave or File → Reload Databases in DVE to reload the waveform file.



## Build Your First Sequential Digital Circuit
In this section, you will design a 4-bit wrap-around counter that increments every one second. The counter value is shown on the LEDS 0-3 of the PYNQ board.

### Clock Sources
Look at the [PYNQ Reference Manual](https://reference.digilentinc.com/reference/programmable-logic/pynq-z1/reference-manual).
Read Section 11 about the clock sources available on the PYNQ.
We are using the 125 MHz clock from the Ethernet PHY IC on the PYNQ board that connects to pin H16 of the FPGA chip.

Look at the `lab2/src/z1top_counter.v` top-level module and its `CLK_125MHZ_FPGA` input.
```verilog
module z1top_counter (
    input CLK_125MHZ_FPGA,
    ...
);
```

We can access the clock signal from our Verilog top-level module and can propagate this clock signal to any submodules that may need it.

### Build a 4-bit Counter

Your circuit receives an input clock signal with a clock period of 8 ns (125 MHz). How many cycles of this clock signal are equivalent to one second? Note that
```
Time (sec) = Clock Period * Number of cycles
```
Build a 4-bit counter that will increment its value every second (and loop back to 0 once all 4 bits are used), and display the corresponding value on bits `3:0` of the IO LEDs. There is one caveat: the counter only counts if a 'clock enable' signal (in this case, called `ce`) is 1. If it's 0, the counter should stay at the same value. Some initial code has been provided in `src/counter.v` to help you get started.

## Simulating the Counter

This time, we'll ask you to write your own testbench! Set the clock enable signal on and off and step time forward to test your counter. A skeleton is provided for you in `sim/counter_testbench.v`. One snippet of code from this file is as follows:

```verilog
initial clock = 0;
always #(4) clock <= ~clock;
```

This is the clock generation code.
The clock signal needs to be generated in our testbench so it can be fed to the DUT.
The initial statement sets the value of the clock net to 0 at the very start of the simulation.
The next line toggles the clock signal every 4ns, i.e. half period of 125 MHz clock.

### Analyzing the Simulation
This time, you *may* see that your counter signal is just a red line. What's going on?

#### Fixing Unknown Signals
Blue lines (written as `Z' in Verilog) in a waveform viewer indicate high-impedance (unconnected) signals.
We won't be using high-impedance signals in our designs, so blue lines or `Z' indicate something in our testbench or DUT isn't wired up properly.

Red lines (written as `X' in Verilog) in a waveform viewer indicate unknown signals.
At the start of simulation, all registers in your DUT contain unknown values (represented as `x').
Since we don't have an explicit reset signal for our circuit to bring the `counter` to a defined value, it may be unknown for the entire simulation.

Let's fix this. In the future we will use a reset signal, but for now let's use a simpler technique. In `src/counter.v` add an initial value to any registers in your design.
```verilog
// Original code:
reg counter;

// Change to:
reg counter = 0;
```

This tells the simulator that the initial value for this register should be 0.
For this lab, when you add new registers in your counter or any other design module, you should instantiate them with their initial value in the same way.

**Do not set an initial value for a 'wire' type net; it will cause issues with synthesis, and may cause X's in simulation.**

Now run the simulation again.

### Run on the FPGA

Once you're confident that your counter works, program the FPGA using `z1top_counter.v` as the top level module. This module connects your counter to the FPGA clock source and connects switch 0 as the clock enable signal.
